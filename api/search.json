[{"id":"4e6cb60fc0598e549d5e42a48c6c7d34","title":"3177. 求出最长好子序列 II / 3176. 求出最长好子序列 I（24.9.7 / 24.9.8）","content":"昨日与今日题目相同，只有数据量变大了\n题目给定一个整数数组 nums 和一个非负整数 k。如果一个整数序列 seq 在范围下标范围 [0, seq.length - 2] 中存在不超过 k 个下标 i 满足 seq[i]!=seq[i + 1]，那么称这个整数序列为好序列。要求返回 nums 中好子序列的最长长度。\n示例 1：输入：nums = [1,2,1,1,3]，k = 2输出：4解释：最长好子序列为 [1,2,1,1]。\n示例 2：输入：nums = [1,2,3,4,5,1]，k = 0输出：2解释：最长好子序列为 [1,1]\n提示：\n\n1 &lt;= nums.length &lt;= 5 * 10^3；\n1 &lt;= nums[i] &lt;= 109；\n0 &lt;= k &lt;= min(50, nums.length)。\n\n解题思路见代码\n代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/*#1 作为第 i 个数，其有三种情况：   1.单独作为一个子序列   2.和上一个好子序列的最后一个相同，加入到结尾   3.和上一个好子序列的最后一个不相同，但是不超过k，加入到结尾#2 所需要的跟踪信息有：子序列的结尾数，相邻不同的个数#3 dp的构造：   //1 构造dp[i][j],表示以 nums[i] 作为结尾，至多有 j 个相邻不同的子序列，记录这个下面的最长子序列的长度   //2 根据 #1 得出下方：         1.作为子序列的第一个数，dp[i][j]+1;         2.作为系序列的末尾，并于末尾的数相同，dp[i][j]+1;         3.作为子序列的末尾，并于末尾的数相同，dp[i][j]=dp[y][j-1]+1;//y为0~i   //3 dp[i][j]的空间大小：i的值为0~n-1，j的值为0~k#1 优化    //dp构造优化：      根据 #3 的 //1 可以优化构造的方式，其中前面的dp[i]表示以nums[i]作为结尾，我们可以通过哈希的方式快速构建    unordered_map&lt;int,vector&lt;int&gt;&gt; dp;    //最大值的维护(对于昨日的I，可以通过暴力枚举y的值而得到，而对于本体暴力枚举则会超时)    假设最大值为max_v[j-1],用于记录dp[y][j-1]的最大值,避免多次寻找y的最大值    */class Solution &#123;public:    int maximumLength(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int,vector&lt;int&gt;&gt; dp;        vector&lt;int&gt; max_v(k+2);        for(int num:nums)&#123;            auto&amp; d=dp[num];            d.resize(k+1);            for(int j=k;j&gt;=0;j--)&#123;                //正着循环则会导致同一个数被统计多次                d[j]=max(d[j],max_v[j])+1;                max_v[j+1]=max(max_v[j+1],d[j]);            &#125;        &#125;        return max_v[k+1];    &#125;&#125;;\n\n","slug":"3177. 求出最长好子序列 II _ 3176. 求出最长好子序列 I（24.9.7 _ 24.9.8）","date":"2024-09-07T08:34:14.689Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"d669121ea552f56ac2d9d46e47fdc0f9","title":"3174. 清除数字（24.9.5）","content":"题目给你一个字符串s。你的任务是重复以下操作删除所有数字字符：删除第一个数字字符以及它左边最近的非数字字符。请你返回删除所有数字字符以后剩下的字符串。\n示例 1：输入：s=&quot;abc&quot;输出：&quot;abc&quot;解释：字符串中没有数字。\n示例 2：输入：s=&quot;cb34&quot;输出：&quot;&quot;解释：一开始，我们对s[2]执行操作，s变为&quot;c4&quot;。然后对s[1]执行操作，s变为空字符串。\n提示：\n\n1 &lt;= s.length &lt;= 100；\ns只包含小写英文字母和数字字符；\n输入保证所有数字都可以按以上操作被删除。\n\n解题思路我们可以将设置一个栈的操作，如果是字母就压入栈当中，如果不是则从栈中取出最顶上的字母。\n代码1234567891011121314class Solution &#123;public:    string clearDigits(string s) &#123;        string st;        for (char c : s) &#123;            if (isdigit(c)) &#123;                st.pop_back();            &#125; else &#123;                st += c;            &#125;        &#125;        return st;    &#125;&#125;;\n\n","slug":"3174. 清除数字（24.9.5）","date":"2024-09-05T13:11:54.385Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"252fc4e279065ae70dacf46f9c6498f2","title":"2860. 让所有学生保持开心的分组方法数（24.9.4）","content":"题目整数数组分组问题给你一个下标从 0 开始、长度为n的整数数组nums，其中n是班级中学生的总数。班主任希望能够在让所有学生保持开心的情况下选出一组学生：\n如果能够满足下述两个条件之一，则认为第i位学生将会保持开心：\n\n这位学生被选中，并且被选中的学生人数严格大于nums[i]。\n这位学生没有被选中，并且被选中的学生人数严格小于nums[i]。\n\n返回能够满足让所有学生保持开心的分组方法的数目。\n示例 1：输入：nums=[1,1]输出：2解释：有两种可行的方法：    - 班主任没有选中学生。    - 班主任选中所有学生形成一组。如果班主任仅选中一个学生来完成分组，那么两个学生都无法保持开心。因此，仅存在两种可行的方法。\n示例 2：输入：nums=[6,0,3,3,6,7,2,7]输出：3解释：存在三种可行的方法：    - 班主任选中下标为 1 的学生形成一组。    - 班主任选中下标为 1、2、3、6 的学生形成一组。    - 班主任选中所有学生形成一组。\n提示\n\n$1\\leq nums.length\\leq10^5$。\n$0\\leq nums[i]\\lt nums.length$。\n\n解题思路123456789本题目的主要难点在于如何去理解题目，首先我们将 nums 进行一个排序。那么题目中的条件就变为了：            对于第 n (n=i-1)位学生：                  这位学生被选中，nums[i] &lt; n                  这位学生没有被选中，nums[i] &gt; n                  【不可能出现 nums[i]==n 的情况，因为对于此为同学来说只能被选或者是不被选】        根据上述条件，作为一个新的方案的条件满足前一个被选，二这个孩子不被选（nums[i-1]&lt;n&lt;nums[i]）                   ，对于第一个学生nums[0]&gt;0则可以不选择，因为如果选择了就说明 nums[i] &lt; 0，是矛盾的                   ，其次每个人都选也可以作为一个方案【nums[i] &lt; nums.length】\n\n代码123456789101112class Solution &#123;public:    int countWays(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        sort(nums.begin(),nums.end());        int ans=nums[0]&gt;0;//查看第一个学生是否可选        for(int i=1;i&lt;n;i++)&#123;            ans+=nums[i-1]&lt;i&amp;&amp;nums[i]&gt;i;        &#125;        return ans+1;//都选    &#125;&#125;;\n\n","slug":"2860. 让所有学生保持开心的分组方法数（24.9.4）","date":"2024-09-04T11:22:24.040Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"9882d257e025c65f209ece6b19bba10c","title":"2708. 一个小组的最大实力值（24.9.3）","content":"题目给定一个下标从 0 开始的整数数组 nums，表示班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个非空小组，且这个小组的实力值最大。如果这个小组里的学生下标为 i0,i1,i2,...ik，那么这个小组的实力值为 nums[i0] * nums[i1] * nums[i2] *... * nums[ik]。要求返回老师创建的小组能得到的最大实力值。\n示例 1：输入：nums=[3,-1,-5,2,5,-9]输出：1350解释：一种构成最大实力值小组的方案是选择下标为[0,2,3,4,5]的学生。实力值为 3*(-5)25*(-9)&#x3D;1350，这是可以得到的最大实力值。\n示例 2：输入：nums=[-4,-5,-4]输出：20解释：选择下标为[0,1]的学生。得到的实力值为 20。我们没法得到更大的实力值。\n提示：\n\n1&lt;=nums.length&lt;=13\n-9&lt;=nums[i]&lt;=9\n\n解题思路假设我一个数为 X ，如果这个数是正数，那么想要其乘积最大，则要和一个 尽可能大的正数相乘，如果是一个负数，则要和一个尽可能小的负数或者是0相乘，从上述思路中我们可以推出以下记录值最大值 最小值，这两个值，要想得到这些值则需要注意以下四个值的比较：自生、当前数字、最大值与当前数字相乘、最小值与当前数字相乘\n代码1234567891011121314151617181920/*要想乘积最大，对于负数而言要是其变为正数，并且尽可能大，即负值当中的最小值在乘以一个负数             对于正数而言则是要求，两个值都大*/class Solution &#123;public:    long long maxStrength(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        long long min_num=nums[0];        long long max_num=nums[0];         for(int i=1;i&lt;n;i++)&#123;            long long num=nums[i];            long long t=min_num;            min_num=min(&#123;min_num,num,min_num*num,max_num*num&#125;);            max_num=max(&#123;max_num,num,t*num,max_num*num&#125;);         &#125;         return max_num;    &#125;&#125;;\n\n","slug":"2708. 一个小组的最大实力值（24.9.3）","date":"2024-09-03T13:00:04.401Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"92ec01a4c530498cacb94a32011f484f","title":"2024. 考试的最大困扰度（24.9.2）","content":"题目一位老师正在出一场由若干道判断题构成的考试，每道题的答案为 true（用 T 表示）或者 false（用 F 表示）。老师想增加学生对自己做出答案的不确定性，方法是最大化有连续相同结果的题数。（也就是连续出现 true 或者连续出现 false）。\n给你一个字符串 answerkey，其中 answerKey[1] 是第 1 个问题的正确结果。除此以外，还给你一个整数 k，表示你能进行以下操作的最多次数：\n\n每次操作中，将问题的正确答案改为 T 或者 F（也就是将 answerkey[] 改为 T 或者 F）。\n\n请你返回在不超过 k 次操作的情况下，最大连续 T 或者 F 的数目。\n示例 1:\n输入：answerkey=&quot;TTFF&quot;,k=2\n输出：4\n解释：我们可以将两个 F 都变为 T，得到 answerKey=&quot;TTTT&quot;，总共有四个连续的 T。\n示例 2:\n输入：answerkey=&quot;TFFT&quot;,k=1\n输出：3\n解释：我们可以将最前面的 T 换成 F，得到 answerKey=&quot;FFF&quot;。或者，我们可以将第二个 T 换成 F，得到 answerKey=&quot;TFFF&quot;。两种情况下，都有三个连续的 F。\n示例 3:\n输入：answerkey=&quot;TTFTTFTT&quot;,k=1\n输出：5\n解释：我们可以将第一个 F 换成 T，得到 answerKey=&quot;TTTFTTT&quot; 或者我们可以将第二个 F 换成 T，得到 answerKey=&quot;TTFTTTTT&quot;。两种情况下，都有五个连续的 T。** \n**提示:\n\nn == answerkey.length\n\n1 &lt;= n &lt;= 5 * 104\n\nanswerkey[i] 要么是 T ，要么是 F  **\n\n\n解题思路1234567891011本题为滑动窗口题目，我们先移动右侧窗口边界，查看最多能有多少个符合条件的，若是不符合则移动左端的窗口边界举例：TTFF k=1当我们 r=0 时，为 T当我们 r=1 时，为 TT ，是连续的当我们 r=2 时，为 TTF ，不是连续的，我们可以通过改变一次达到，变为TTT当我们 r=3 时，为 TFF ，不是连续的，我们可以通过改变一次达到，变为FFF答案为3连续性的特点：此处我们需要注意的是，我们在一个窗口中， T 和 F 必须有其中一个值小于 k ，因为只有小于 k 的时候才能保证经过 k 次改变达到连续的状态。一个窗口符合这样的窗口的长度为 （右边界-左边界+1）。我们只需要检查到究竟有几个窗口符合连续性的特点，并且其最大值即可\n\n代码12345678910111213141516class Solution &#123;public:    int maxConsecutiveAnswers(string answerKey, int k) &#123;        int n=answerKey.size();        unordered_map&lt;char,int&gt; h;        h[&#x27;T&#x27;]=0,h[&#x27;F&#x27;]=0;        int ans=0,l=0;        for(int r=0;r&lt;n;r++)&#123;            h[answerKey[r]]++;//记录前r里面有几个 T/F            if(h[&#x27;T&#x27;]&gt;k&amp;&amp;h[&#x27;F&#x27;]&gt;k) h[answerKey[l++]]--;            //cout&lt;&lt;h[&#x27;T&#x27;]&lt;&lt;endl;            ans=max(ans,r-l+1);        &#125;        return ans;    &#125;&#125;;\n\n","slug":"2024. 考试的最大困扰度（24.9.2）","date":"2024-09-02T08:41:21.305Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"2609c3426ae5a030fa986c53ab2f4c07","title":"1450. 在既定时间做作业的学生人数（24.9.1）","content":"题目给定两个整数数组startTime（开始时间）和endTime（结束时间），并指定一个整数queryTime作为查询时间。已知，第i名学生在startTime[i]时开始写作业，并于endTime[i]时完成作业。\n请返回在查询时间queryTime时正在做作业的学生人数。形式上，返回能够使queryTime处于区间[startTime[i], endTime[i]]（含）的学生人数。\n示例 1：输入：startTime=[1,2,3]，endTime=[3,2,7]，queryTime=4输出：1解释：一共有 3 名学生。第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是唯一一名在时间 4 时正在做作业的学生。\n示例 2：输入：startTime=[4]，endTime=[4]，queryTime=4输出：1解释：在查询时间只有一名学生在做作业。\n示例 3：输入：startTime=[4]，endTime=[4]，queryTime=5输出：0\n示例 4：输入：startTime=[1,1,1,1]，endTime=[1,3,2,4]，queryTime=7输出：0\n示例 5：输入：startTime=[9,8,7,6,5,4,3,2,1]，endTime=[10,10,10,10,10,10,10,10,10]，queryTime=5输出：5\n提示:\n\nstartTime.Length == endTime.length\n1 &lt;= startTime.length &lt;= 100\n1 &lt;= startTime [i] &lt;= endTime [i] &lt;= 1000\n1 &lt;= queryTime &lt;= 1000\n\n解题思路本体只需要一次遍历，查看第 i 个学生开始时间和结束时间是否包括了 queryTime 的值\n代码12345678910class Solution &#123;public:    int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) &#123;        int ans=0;        for(int i=0;i&lt;startTime.size();i++)&#123;            if(queryTime&gt;=startTime[i]&amp;&amp;queryTime&lt;=endTime[i]) ans++;        &#125;        return ans;    &#125;&#125;;\n\n","slug":"1450. 在既定时间做作业的学生人数（24.9.1）","date":"2024-09-01T15:14:57.585Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"ac1e7f8a586362e2b6befd5e5f2f538d","title":"3127. 构造相同颜色的正方形（24.8.31）","content":"题目给你一个二维 3x3 的矩阵 grid，每个格子都是一个字符，要么是 &#39;B&#39; ，要么是 &#39;W&#39;。字符 &#39;W&#39; 表示白色，字符 &#39;B&#39; 表示黑色。你的任务是改变至多一个格子的颜色，使得矩阵中存在一个 2x2 颜色完全相同的正方形。 如果可以得到一个相同颜色的 2x2 正方形，那么返回 true ，否则返回 false\n 示例 1:\n输入: grid=[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;]\n输出: true\n解释: 修改 grid[0][2] 的颜色，可以满足要求。\n示例 2:\n输入: grid=[&quot;B&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;W&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;]\n输出: false\n解释: 只改变一个格子颜色无法满足要求。\n示例 3:\n输入: grid=[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;],[&quot;W&quot;,&quot;W&quot;,&quot;W&quot;],[&quot;B&quot;,&quot;W&quot;,&quot;B&quot;]\n输出: true\n解释: grid 已经包含一个 2x2 颜色相同的正方形了。\n解题思路123对于 3*3 的格子而言，要想得到 2*2 的格子只需要确定其左上角的点即可知道其余点的位置假设其左上角点的坐标为（i , j），则其余点为：（i+1 , j），（i+1 , j+1），（i , j+1）对于一个 2*2 的格子而言，要想满足情况则要求只存在一黑或者一白的状况（假设统计的是白，则白色个数为1，3，4，即不为2）\n\n代码123456789101112131415class Solution &#123;public:     bool canMakeSquare(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        auto         check=[&amp;](int i,int j)&#123;            int ans=0;            if(grid[i][j]==&#x27;W&#x27;) ans++;            if(grid[i+1][j]==&#x27;W&#x27;) ans++;            if(grid[i+1][j+1]==&#x27;W&#x27;) ans++;            if(grid[i][j+1]==&#x27;W&#x27;) ans++;            return ans!=2;        &#125;;        return check(0,0)||check(0,1)||check(1,0)||check(1,1);    &#125;&#125;;\n\n","slug":"3127. 构造相同颜色的正方形（24.8.31）","date":"2024-08-31T12:47:49.443Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"2c2935447551654aa17167ce96c927c4","title":"3153. 所有数对中数位不同之和（24.8.30）","content":"题目题目\n你有一个数组 nums ，它只包含正整数，所有正整数的数位长度都相同。两个整数的数位不同指的是两个整数相同位置上不同数字的数目。请返回 nums 中所有整数对里，数位不同之和。\n示例 1\n输入：nums=[13,23,12]\n输出：4\n解释：计算过程如下:\n\n13 和 23 的数位不同为 1。\n13 和 12 的数位不同为 1。\n23 和 12 的数位不同为 2。\n\n所以所有整数数对的数位不同之和为 1 + 1 + 2 &#x3D; 4 。\n题目\n示例 2：\n输入：nums =[10,10,10,10]\n输出：0\n解释：\n数组中所有整数都相同，所以所有整数数对的数位不同之和为 0。\n提示\n2&lt;=nums.Length&lt;=10^5\n1&lt;=nums[i]&lt;10^9\nnums 中的整数都有相同的数位长度。\n解题思路见代码\n代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public:    long long sumDigitDifferences(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        //nums 中的整数都有相同的数位长度         int len=to_string(nums[0]).size();//数的位数          long long ans=0;        vector&lt;array&lt;int,10&gt;&gt; cnt(len);        /*        此处相当于 cnt[数的位数][0~9的数字]        对于例1而论：         个  十         1   3         2   3         1   2         对于第 n 个数字的第 i 位而言，假设此位的数字时 a：            cnt[i][a]的数表示为前 n 个数在 i 位出现的数字 a 的个数，即与此数的此位相同的数的个数            对于此数的 i 位而言，n - cnt[i][a] 则表示不同的个数         对于第 1 位而言，1 2 1，         //第一个数为：0-0，即第一个数在第一位没有不同的个数         //第二个数为：1-0，即第一个数在第一位有 1 不同的个数            //第三个数为：2-1，即第一个数在第一位有 1 不同的个数          */                for(int i=0;i&lt;n;i++)&#123;            int num=nums[i];            int wei=0;            while(num)&#123;                ans+=i-cnt[wei][num%10];                cnt[wei++][num%10]++;                num/=10;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3153. 所有数对中数位不同之和（24.8.30）","date":"2024-08-29T17:52:04.514Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"32a2a21e126367c44904ea628e1e3188","title":"142. 判断矩阵是否满足条件（24.8.29）","content":"题目给你一个大小为 m×n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足:\n\n如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。\n如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j]!= grid[i][j + 1] 。\n\n如果所有格子都满足以上条件，那么返回 true ，否则返回 false 。\n\n示例 1: 输入: grid = [[1,0,2],[1,0,2]] 输出: true  解释:网格图中所有格子都符合条件。\n\n\n示例 2: 输入: grid = [[1,1,1],[0,0,0]] 输出: false  解释:同一行中的格子值都相等。\n\n\n示例 3: 输入: grid = [[1],[2],[3]] 输出: false 解释:同一列中的格子值不相等。\n\n提示:1 &lt;&#x3D; n,m &lt;&#x3D; 100 &lt;&#x3D; grid[i][j] &lt;&#x3D; 9\n解题思路本题目只需要遍历一次，首先记录一下其纵向(m)和横向(n)的长度，判断此点( 设坐标为 ( i , j ) )下方是否有格子(i+1&lt;m)，若有则判断是否不相等，再判断此点右方是否有格子(j+1&lt;n)，若有则判断其是否相等，若上方有一个条件满足就返回 false，最后遍历结束都没有返回值，则说明其符合题目中的条件，返回true。\n代码12345678910111213class Solution &#123;public:    bool satisfiesConditions(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m=grid.size(),n=grid[0].size();        for(int i=0;i&lt;m;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                if(i+1&lt;m&amp;&amp;grid[i][j]!=grid[i+1][j]) return false;                 if(j+1&lt;n&amp;&amp;grid[i][j]==grid[i][j+1]) return false;            &#125;        &#125;        return true;    &#125;&#125;;\n\n","slug":"142. 判断矩阵是否满足条件（24.8.29）","date":"2024-08-29T12:47:24.409Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"b47e0977c91a3294eec04548018a37a6","title":"3144. 分割字符频率相等的最少子字符串（24.8.28）","content":"题目题目：给你一个字符串 s ，你需要将它分割成一个或者更多的平衡子字符串。 比方说，s == &quot;ababcc&quot; 那么 (&quot;abab&quot;,&quot;c&quot;,&quot;c&quot;) ，(&quot;ab&quot;,&quot;abc&quot;,&quot;c&quot;) 和 (&quot;ababcc&quot;) 都是合法分割，但是 (&quot;a&quot;,&quot;bab&quot;,&quot;cc&quot;) ， (&quot;aba&quot;,&quot;bc&quot;,&quot;c&quot;) 和 (&quot;ab&quot;,&quot;abc&quot;) 不是，不平衡的子字符串用粗体表示。\n请你返回 s 最少能分割成多少个平衡子字符串。\n注意：一个平衡字符串指的是字符串中所有字符出现的次数都相同。\n示例 1：输入：s = &quot;fabccddg&quot;输出：3解释：我们可以将 s 分割成 3 个子字符串：(&quot;fab&quot;,&quot;ccdd&quot;,&quot;g&quot;) 或者 (&quot;fabc&quot;,&quot;cd&quot;,&quot;dg&quot;) 。\n示例 2：输入：s = &quot;abababaccddb&quot;输出：2解释：题目：我们可以将 s 分割成 2 个子字符串：(&quot;abab&quot;,&quot;abaccddb&quot;) 。\n提示：\n\n1&lt;=s.length&lt;=1000\ns 只包含小写英文字母。\n\n解题思路见代码\n代码123456789101112131415161718192021222324252627282930313233343536/*要求求最小的分割数，那么就要求每个字串都要达到尽可能长的长度。可以从大到小枚举其长度， */class Solution &#123;public:    int minimumSubstringsInPartition(string s) &#123;        int n=s.size();        vector&lt;int&gt; cnt(n);//用于记录遇到的长度        //由大到小枚举 子串的长度         auto dfs = [&amp;](auto&amp;&amp; dfs, int i) -&gt; int&#123;            if(i&lt;0) return 0;//因为长度不可能小于0            int&amp; ans=cnt[i];//将ans初始化为对应i长度的记录值            if(ans) return ans;//如果此长度及路过就不在继续            ans=INT_MAX;//由于是求最小值，九江ans初始化为最大的值，以便于后面的ans值的更新            int h[26]&#123;&#125;;//建立字母的哈希值进行对字母的统计,用于判断是否满足平衡的概念            int k=0;//统计不同字符的个数            int max_h=0;//最大的字符个数            //从第 i 小标开始向前查看这个子串是否满足            for(int j=i;j&gt;=0;j--)&#123;                k+=(h[s[j]-&#x27;a&#x27;]++==0);//统计不同字符的个数                max_h = max(max_h, h[s[j] - &#x27;a&#x27;]);//最大的字符个数                //子集当中字符个数（暂写为 a） i - j + 1                //假设其是平衡的 那么其个数是（暂写为 b） k * max_h                //如果 a==b 则说明满足条件，那么将ans更新为最小值                if (i - j + 1 == k * max_h)&#123;                    ans=min(ans,dfs(dfs,j-1)+1);                    //再去深搜下一个长度是否满足 再加上此子集的个数 1                &#125;            &#125;            return ans;        &#125;;        return dfs(dfs,n-1);    &#125;&#125;;\n\n","slug":"3144. 分割字符频率相等的最少子字符串（24.8.28）","date":"2024-08-28T09:34:09.596Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"63e43b7253423aa57a51b39a198e62b6","title":"3134. 找出唯一性数组的中位数（24.8.27）","content":"前言本次通过学习 灵茶山艾府 的代码进行解题研究\n题目题目描述：\n给你一个整数数组 nums 。数组 nums 的唯一性数组是一个按元素从小到大排序的数组，包含了 nums 的所有非空子数组中不同元素的个数。\n换句话说，这是由所有 0 &lt;= i &lt;= j &lt; nums.Length 的 distinct(nums[i..j]) 组成的递增数组。其中，distinct(nums[..j]) 表示从下标 i 到下标 j 的子数组中不同元素的数量。\n返回 nums 唯一性数组的中位数。\n注意，数组的中位数定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。\n示例 1：\n输入：nums=[1,2,3]\n输出：1\n解释：\nnums 的唯一性数组为 [distinct(nums[(0..0)], distinct(nums[1..1]), distinct(nums [2.2]), distinct(nums[0..1]), distinct(nums[1..2]), distinct(nums[0..2])]，即 [1,1,1,2,2,3] 。唯一性数组的中位数为 1 ，因此答案是 1 。示例 2：\n输入：nums=[3,4,3,4,5]\n输出：2\n解释：\nnums 的唯一性数组为 [1,1,1,1,1,2,2,2,2,2,2,2,3,3,3] 。唯一性数组的中位数为 2 ，因此答案是 2 。\n示例 3：\n输入：nums=[4,3,5,4]\n输出：2\n解释：\nnums 的唯一性数组为 [1,1,1,1,2,2,2,3,3,3] 。唯一性数组的中位数为 2 ，因此答案是 2 。\n提示：\n\n1&lt;=nums.Length&lt;=105\n\n1&lt;=nums[i]&lt;=105\n\n\n解题思路见代码\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*子数组 是数组中连续的 非空 元素序列子集的个数 :            子集中数的个数: 1 2   3   4    ... n            这个子集的个数: n n-1 n-2 n-3  ... 1            数总和（由等差数列求和得）：（n+1）*n/2中位数：数组的 中位数 定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个       假设一个数组有 3 个数，则中位数是 1       假设一个数组有 4 个数，则中位数是 1       假设一个数组有 2k+1 个数，则中位数是 k+1【((2k+1)+1)/2】       假设一个数组有 2k 个数，则中位数是 k-1 【(2k+1)/2】       --&gt;假设一个数组有 n 个数，则中位数是 (n+1)/2*/class Solution &#123;public:    int medianOfUniquenessArray(vector&lt;int&gt;&amp; nums) &#123;        int n=nums.size();        long long k=((long long)n*(n+1)/2+1)/2;//数组的个数        /*        设子数组的个数为 cnt，如果 cnt&lt;k         说明二分的 m 小了，更新二分左边界 left，否则更新二分右边界 right        */        auto solve=[&amp;](int m)&#123;            long long cnt=0;            int left=0;            unordered_map&lt;int, int&gt; h;//记录次数            //滑动窗口的模板            //先固定左端，移动右端            for(int left=0,right=0;right&lt;n;right++)&#123;                h[nums[right]]++;                //当大于 m 即大于了的子数组个数                //窗户口元素过多了                while(h.size()&gt;m)&#123;                    h[nums[left]]--;//减去多余的统计个数                    if(h[nums[left]]==0)&#123;                        h.erase(nums[left]);//删除多余的窗口统计                    &#125;                    left++;//将左边界向右移动一位                &#125;                cnt+=right-left+1; // 右端点固定为 r 时，有 r-l+1 个合法左端点                if(cnt&gt;=k) return true;            &#125;            return false;        &#125;;        int l=0,r=n;        /*        二分的内容是 distinct的数组中的内容        比如实例1：        nums = [1,2,3],distinct=[1, 1, 1, 2, 2, 3], ans=1        l=0,r=3,mid=1，k=3        进入solve当中，        进行第一轮操作后，left=0,right=0，h.size()=1，cnt=1&lt;k        进行第二轮操作后，left=0,right=1，h.size()=2&gt;m,窗口滑动一次,left++,cnt=2&lt;k        进行第三轮操作后，left=1,right=2，h.size()=2&gt;m,窗口滑动一次,left++,cnt=3=k，即此刻说明我所组成的子数组数已经达到我所求的k的位置        */        while(l+1&lt;r)&#123;            int mid=(l+r)/2;            if(solve(mid)) r=mid;            else l=mid;        &#125;        return r;    &#125;&#125;;\n\n","slug":"3134. 找出唯一性数组的中位数（24.8.27）","date":"2024-08-27T13:41:20.004Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"02a34e1e4a78b84dd421c121c20c981e","title":"690. 员工的重要性（24.8.26）","content":"题目题目描述：\n你拥有一个用于保存员工信息的数据结构，其中包含员工唯一的id、重要度以及直系下属的id。\n给定一个员工数组employees，其中：\n\nemployees[i].id是第i个员工的ID。\nemployees[i].importance是第i个员工的重要度。\nemployees[i].subordinates是第i名员工的直接下属的ID列表。\n\n给定一个整数id表示一个员工的ID，要求返回这个员工和他所有下属的重要度的总和。示例 1：：输入：employees =[[1,5,[2,3]],[2,3,[]],[3,3,[]]],id=1\n输出：11\n解释：员工 1 自身的重要度是 5，他有两个直系下属 2 和 3，而且 2 和 3 的重要度均为 3。因此员工 1 的总重要度是 5 + 3 + 3 &#x3D; 11。示例 2：：输入：employees =[[1,2,[5]],[5,-3,[]]],id=5\n输出：-3\n解释：员工 5 的重要度为 -3 并且没有直接下属。 因此，员工 5 的总重要度为 -3。\n提示：\n\n1&lt;=employees.Length&lt;=2000\n1&lt;=employees[i].id&lt;=2000 ，所有的 employees[i].id 互不相同。\n-100&lt;=employees[i].importance &lt;=100\n一名员工最多有一名直接领导，并可能有多名下属。employees[1].subordinates 中的 ID 都有效。\n\n解题思路12（1）首先使用 哈希 来存储对用的 id 和员工信息，以便于后面进行搜索（2）使用 dfs 对 id 员工进行深搜，再对其 下属员工 进行深搜\n\n代码12345678910111213141516171819202122232425262728/*// Definition for Employee.class Employee &#123;public:    int id;    int importance;    vector&lt;int&gt; subordinates;&#125;;*/class Solution &#123;public:    int getImportance(vector&lt;Employee*&gt; employees, int id) &#123;        unordered_map&lt;int,Employee*&gt; h;//id Employee        for(auto per:employees)&#123;            h[per-&gt;id]=per;        &#125;        auto dfs=[&amp;](auto&amp;&amp; dfs,int ids)-&gt;int&#123;            auto one=h[ids];            int ans=one-&gt;importance;            for(auto last_id:one-&gt;subordinates)&#123;                ans+=dfs(dfs,last_id);            &#125;            return ans;        &#125;;        return dfs(dfs,id);    &#125;&#125;;\n\n","slug":"690. 员工的重要性（24.8.26）","date":"2024-08-26T08:53:00.199Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"12bdcd1d7f4735436cddbaffefc6bba4","title":"698. 划分为k个相等的子集（24.8.26）","content":"题目题目：给定一个整数数组 nums 和一个正整数 k ，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。\n示例 1：输入：nums=[4,3,2,3,5,2,1]，k=4输出：True说明：有可能将其分成 4 个子集 (5)，(1,4)，(2,3)，(2,3) 等于总和。\n示例 2：输入：nums =[1,2,3,4]，k=3输出：False\n提示：\n\n1&lt;=k&lt;= len( nums )&lt;=16\n0&lt;nums[i]&lt;10000\n每个元素的频率在 [1,4] 范围内\n\n解题思路（一些注意点放在代码当中）123456###（1）题目要求能将 nums 划分为 k 个和相同的子集，这一点说明了 nums 当中的和( sum )是 k 的正整数。（2）在（1）的前提下，假设 nums 能够成立，那么就存在 k 个子集，问题就变成了向这 k 个自己当中填数，使其满足和为  sum/k（下方记作 sum ，表示每个集合的值）（3）从第一个数开始 向 第 i 个自己当中填入这个数，如果这个数填入后大于 sum，则不可以填入 这个值，相应的回溯减去这个值，转而尝试将下一个数填入其中\n代码1234567891011121314151617181920212223class Solution &#123;public:    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;        int n=nums.size();        int sum = accumulate(nums.begin(), nums.end(), 0);        if(sum%k) return false;//不能被整除，说明无法被分成 k 份        sum/=k;        sort(nums.begin(),nums.end(),greater&lt;int&gt;());//此处由大到小，可以实现剪枝的目的        vector&lt;int&gt; zu(k);        function&lt;bool(int)&gt; dfs=[&amp;](int index)&#123;                if(index==n) return true;//已经分配完了，说明成立                for(int i=0;i&lt;k;i++)&#123;                    if(i&amp;&amp;zu[i]==zu[i-1]) continue;//防止 i 越界，同时当两组集合达到相同值时也说明达到了目标数                        zu[i]+=nums[index];                    if(zu[i]&lt;=sum&amp;&amp;dfs(index+1)) return true;                    zu[i]-=nums[index];                &#125;                return false;                &#125;;        return dfs(0);    &#125;&#125;;\n\n","slug":"698. 划分为k个相等的子集（24.8.26）","date":"2024-08-25T16:00:37.016Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"3ce3d18d242af69716fd71eef0e0c088","title":"3146. 两个字符串的排列差（24.8.24）","content":"\n附：本体力扣个人解题链接\n\n题目给你两个字符串 s 和 t，每个字符串中的字符都不重复，且 t 是 s 的一个排列。\n排列差定义为 s 和 t 中每个字符在两个字符串中位置的绝对差值之和。\n返回 s 和 t 之间的排列差。示例 1:\n输入: s=&quot;abc&quot;, t= &quot;bac&quot;\n输出: 2\n解释:\n对于 s=&quot;abc&quot; 和 t=&quot;bac&quot;，排列差是:\n· “a” 在 s 中的位置与在 t 中的位置之差的绝对值。\n· “b” 在 s 中的位置与在 t 中的位置之差的绝对值。\n· “c” 在 s 中的位置与在 t 中的位置之差的绝对值。\n|0 - 1| + |2 - 2| + |1 - 0| = 2 。示例 2:\n输入: s=&quot;abcde&quot;, t= &quot;edbac&quot;\n输出: 12  |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12 。\n提示:\n· 1 &lt;= s.length &lt;= 26\n· 每个字符在 s 中最多出现一次。\n· t 是 s 的一个排列。\n· s 仅由小写英文字母组成。\n解题思路首先遍历 s 中的字符串，将其下标记录在 哈希表 当中，在通过遍历 t 中的字符进行串并访问哈希表，将记录值与哈希表中的值进行相减取绝对值加入到结果当中，最后返回结果\n代码1234567891011121314151617class Solution &#123;public:    int findPermutationDifference(string s, string t) &#123;        unordered_map&lt;char,int&gt; h;        int ans=0,l=s.size();        for(int i=0;i&lt;l;i++)        &#123;            h[s[i]]=i;        &#125;        for(int i=0;i&lt;l;i++)        &#123;            ans+=abs(i-h[t[i]]);        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3146. 两个字符串的排列差（24.8.24）","date":"2024-08-23T16:46:44.011Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"3b903ad0609a994931dc6b6a42c85357","title":"3145. 大数组元素的乘积（24.8.23）","content":"前言今日每日一题难度较大，根据 灵茶山艾府 的代码进行学习研究\n题目一个非负整数x的强数组指的是满足元为 2 的且元素总和为x的有序数。下表说明了如何确定强数的示例,可以证明,对应的数组是独一无二的。\n\n\n\n数字\n二进制表示\n强数组\n\n\n\n1\n00001\n[1]\n\n\n8\n01000\n[8]\n\n\n10\n01010\n[2, 8]\n\n\n13\n01101\n[1, 4, 8]\n\n\n23\n10111\n[1, 2, 4, 16]\n\n\n我们将一个升序的正整数 1(即 1,2,3 等等)的强数组连接得组big_nums，big_nums开始部分为：[1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, ...]\n给你一个二维整数数组queries，其中queries[i] = [fromi, toi, modi]，你需要计算(big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]) % modi\n请你返回一个整数数组answer，其中answer[i]是第i个查词的答案。\n示例 1:\n输入：queries = [[3,7]]\n输出：[4]\n解释：\n只有一个查询。\nbig_ums[1..3] = [2.1.2]，它们的积为 4，结果为4 mod 7 = 4。\n示例 2:\n输入：queries = [[1,2,5],[3,7,3],[7,7,4]]\n输出：[2,2]\n解释：\n有两个查询。\n第一个查询：big_nua[2..5] = [1.2,4,2]，它们的所积为 8，结果为8 mod 3 = 2。\n第二个查询：big_nuas[7]，结果为2 mod 4 = 2。\n提示:\n· 1 &lt;= queries.length &lt;= 500\n· queries[i].length = 3\n· queris[i][0] &lt;= quers[i][1] &lt;= 10^15\n· 1 &lt;= queries[i][2] &lt;= 10^5\n解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182强数组：###概念说明：    ###（1） 强数组 ：         例如： 10                   【强数组为：2，8】         位数： 4 | 3 | 2 | 1 | 0   【二进制的位数】         转化： 0 | 1 | 0 | 1 | 0   【转化为二进制】    强数组：              第 1 位是 1 则有一个强数组的数：2^1  --&gt; 2              第 3 位是 3 则有一个强数组的数：2^3  --&gt; 8        强数组为这些数的集合：[2,8]      总结为：             第 i 位是 1 则有一个强数组的数：2^i              由这样的数组成的集合为 强数组        ###（2） big_nums ：         由 1，2，3，4，...，n 的强数组拼接而成的强数组    ###（3） (big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]) % modi ：         假设 big_nums 第 i 个数的幂表示为 2^k(i)         假设 queries[i] = [a, b, modi]         设：SUM( fromi , toi ) = big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]         则计算变为： SUM( a , b ) % modi             对于此处 SUM 而言：                          SUM( a , b ) = big_nums[a] * big_nums[a + 1] * ... * big_nums[b]                              = (2^k(a))*(2^k(a+1))*(2^k(a+2))*...*(2^k(b))                              = 2^(k(a)+k(a+1)+...+k(b))              ###问题转化：           通过上述的（3），我们可以将 big_nums 记录强数组 转化为 记录强数组当中 2 的幂                                  将 big_nums 之间的乘 转化为 幂的加法                         ， 假设强数组前 i 个幂之和为 sum(i),则上方（3）中的SUM( a , b )=2^[sum(b)-sum(a)]###列举：数字(n)  强数组      转化为2的幂     big_nums(转化后的)                数组当中的个数(i)       sum(i)0        []         []             []                                     0                 01        [1]        [0]            [0]                                    1                 02        [2]        [1]            [0,1]                                  2                 13        [1,2]      [0,1]          [0,1,0,1]                              4                 24        [4]        [2]            [0,1,0,1,2]                            5                 45        [1,4]      [0,2]          [0,1,0,1,2,0,2]                        7                 66        [2,4]      [1,2]          [0,1,0,1,2,0,2,1,2]                    9                 97        [1,2,4]    [0,1,2]        [0,1,0,1,2,0,2,1,2,0,1,2]              12                128        [8]        [3]            [0,1,0,1,2,0,2,1,2,0,1,2,3]            13                15...      [...]      [...]          [0,1,0,1,2,0,2,1,2,0,1,2,3,...]        ???               ???###规律找寻：对于 i 而言，其值是其二进制当中 1 出现的个数： !!! 设 前 2^i 个强数组有 a(i) 个,则 前 2^(i+1) 个强数组有 a(i+1) 个**********************数字(n)  强数组      转化为2的幂     0        []         []            1        [1]        [0]            2        [2]        [1]            3        [1,2]      [0,1]         4        [4]        [2]             = [ ]   +  [2]         5        [1,4]      [0,2]           = [0]   +  [2]6        [2,4]      [1,2]           = [1]   +  [2]7        [1,2,4]    [0,1,2]         = [0,1] +  [2]              a(i+1) = a(i)*2 + 2^i**********************前 1  个强数组的个数为 0  前 2  个强数组的个数为 1  前 4  个强数组的个数为 4  前 8  个强数组的个数为 12 a(0)=0 a(1)=1 a(2)=4 a(3)=12==&gt; a(i+1) = a(i)*2 + 2^i ==&gt;a(i+1)/(2^(i+1)) = a(i)/(2^i) + 1/2 【等差数列】--&gt; a(i)=i*2^(i-1)求前 k 个幂之和，则需要求的 k 个幂次是由多少个强数组组成的，即要找到一个最大的 n 使得 a(n)&lt;=k!!! 采用 试填法 见下方代码求 幂次 之和：同上方 a() 的推倒过程sum(i) = (i*(i-1)/2)*2^(i-1)\n代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;    //快速幂：    int pow(long long x, long long n, long long mod) &#123;        long long res = 1 % mod;        for (; n; n /= 2) &#123;            if (n % 2) &#123;                res = res * x % mod;            &#125;            x = x * x % mod;        &#125;        return res;    &#125;    //试填法     long long sum(long long k) &#123;        long long res = 0, n = 0, cnt1 = 0, sum_i = 0;        for (long long i = __lg(k + 1); i; i--) &#123;            long long c = (cnt1 &lt;&lt; i) + (i &lt;&lt; (i - 1)); // 新增的幂次个数            if (c &lt;= k) &#123;                k -= c;                res += (sum_i &lt;&lt; i) + ((i * (i - 1) / 2) &lt;&lt; (i - 1));                sum_i += i; // 之前填的 1 的幂次之和                cnt1++; // 之前填的 1 的个数                n |= 1LL &lt;&lt; i; // 填 1            &#125;        &#125;        // 最低位单独计算        if (cnt1 &lt;= k) &#123;            k -= cnt1;            res += sum_i;            n |= 1; // 最低位填 1        &#125;        // 剩余的 k 个幂次，由 n 的低 k 个 1 补充        while (k--) &#123;            res += __builtin_ctzll(n);            n &amp;= n - 1; // 去掉最低位的 1（置为 0）        &#125;        return res;    &#125;public:    vector&lt;int&gt; findProductsOfElements(vector&lt;vector&lt;long long&gt;&gt;&amp; queries) &#123;        vector&lt;int&gt; ans;        for (auto&amp; q : queries) &#123;            auto r = sum(q[1] + 1);            auto l = sum(q[0]);            ans.push_back(pow(2, r - l, q[2]));        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3145. 大数组元素的乘积（24.8.23）","date":"2024-08-23T16:18:43.997Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"cf59c4e264dda7bae571ae182b9243c4","title":"3133. 数组最后一个元素的最小值（24.8.22）","content":"题目\n给你两个整数 n 和 x 。你需要构造一个长度为 n 的 正整数 数组 nums ，对于所有 0 &lt;&#x3D; i &lt; n - 1 ，满足 nums[i + 1] 大于 nums[i] ，并且数组 nums 中所有元素的按位 AND 运算结果为 x 。\n返回 nums[n - 1] 可能的 最小 值。\n\n\n示例 1：输入：n &#x3D; 3, x &#x3D; 4输出：6解释：数组 nums 可以是 [4,5,6] ，最后一个元素为 6 。\n\n\n示例 2：输入：n &#x3D; 2, x &#x3D; 7输出：15解释：数组 nums 可以是 [7,15] ，最后一个元素为 15 。\n\n\n提示：1 &lt;&#x3D; n, x &lt;&#x3D; 108\n\n解题思路12345678910111213141516171819对于 AND 运算：        1.  和0： 0 &amp; 1 = 0 / 0 &amp; 0 = 0        2.  和1： 1 &amp; 1 = 1        3.   AND 运算的结果只会越来越小由（3）可知，第一个数字我们需要保证是大于等于 x ，由于题目要求最小，因此第一个数为 x例1： 以下数字省略前置的 0         4   1 0 0        5   1 0 1        6   1 1 0        无论 x 和什么数进行 AND 运算， 0 处的数字依旧是 0 ；        如果要想最后计算的结果还是 x 的话，则需要维护 1 的位；        去除数字 1 最小的取值变为：（下方称之为自然序列）        值    00  , 01   ,  10        num   0   ,  1   ,  2       对应n  n-3 , n-2 ,  n-1        于此对此创建一个自然序列：           0000,0001,0010,0011,0100,0101,⋯           我们的答案则是取第 n-1 个自然序列，并将其更新到原有的位置\n\n代码1234567891011121314151617181920212223class Solution &#123;public:    long long minEnd(int n, int x) &#123;        n--;//减去第一个数 x        int i=0,j=0;        long long ans=x;        //逐位运算：        // n&gt;&gt;j , 向前移动 j 位 ，直到最后一位：n&gt;&gt;j=0        while(n&gt;&gt;j)&#123;            //如果第 i 位是 0            if((ans &gt;&gt; i &amp; 1)==0)&#123;                ans|=(long long)(n&gt;&gt;j&amp;1)&lt;&lt;i;                //n&gt;&gt;j 表示取第 n-1 个自然数序列的第 j 位的数，添加到第 i 位                //通过 | 运算更新 ans 的值                //去 0 值的                j++;            &#125;            //将第 n-1 个自然数序列向前进 1 位，用于下一个地方的 i 位的更新            i++;        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3133. 数组最后一个元素的最小值（24.8.22）","date":"2024-08-22T03:34:27.520Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"b6a8fdfd69b81dc71582047e56586849","title":"3007. 价值和小于等于 K 的最大数字（24.8.21）","content":"题目给你一个整数 k 和一个整数 x 。整数 num 的价值是它的二进制表示中在 x，2x，3x 等位置处设置位的数目（从最低有效位开始）。下面的表格包含了如何计算价值的例子。\n\n\n\nX\nnum\nBinary Representation\nPrice\n\n\n\n1\n13\n000001101\n3\n\n\n2\n13\n000001101\n1\n\n\n2\n233\n011101001\n3\n\n\n3\n13\n000001101\n1\n\n\n3\n362\n101101010\n2\n\n\nnum 的 累加价值 是从 1 到 num 的数字的 总 价值。如果 num 的累加价值小于或等于 k 则被认为是 廉价的。\n请你返回 最大 的廉价数字。 \n示例 1：\n\n输入：k &#x3D; 9, x &#x3D; 1输出：6解释：由下表所示，6 是最大的廉价数字。\n\n\n\n\nX\nnum\nBinary Representation\nPrice\nAccumulated Price\n\n\n\n1\n1\n001\n1\n1\n\n\n1\n2\n010\n1\n2\n\n\n1\n3\n011\n2\n4\n\n\n1\n4\n100\n1\n5\n\n\n1\n5\n101\n2\n7\n\n\n1\n6\n110\n2\n9\n\n\n1\n7\n111\n3\n12\n\n\n 示例 2：\n\n输入：k &#x3D; 7, x &#x3D; 2输出：9解释：由下表所示，9 是最大的廉价数字。\n\n\n\n\nX\nnum\nBinary Representation\nPrice\nAccumulated Price\n\n\n\n2\n1\n0001\n0\n0\n\n\n2\n2\n0010\n1\n1\n\n\n2\n3\n0011\n1\n2\n\n\n2\n4\n0100\n0\n2\n\n\n2\n5\n0101\n0\n2\n\n\n2\n6\n0110\n1\n3\n\n\n2\n7\n0111\n1\n4\n\n\n2\n8\n1000\n1\n5\n\n\n2\n9\n1001\n1\n6\n\n\n2\n10\n1010\n2\n8\n\n\n提示：\n1 &lt;&#x3D; k &lt;&#x3D; 10151 &lt;&#x3D; x &lt;&#x3D; 8\n解题思路见代码内\n代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public:    long long findMaximumNumber(long long k, int x) &#123;        //二分查找的过程        long long left=1,right=(k+1)&lt;&lt;x;        while(left&lt;right)&#123;            long long mid=(left+right+1)/2;            if(Sum(x,mid)&gt;k)&#123;                //如果比 k 大 说明答案在mid左边                right=mid-1;            &#125;            else&#123;                //如果比 k 小 说明在mid右边                left=mid;            &#125;        &#125;        return left;    &#125;//求解从 1 到 num 所有整数在二进制表示下在 i 位置处设置位的数字之和/*规律：            1 2 3 4 5 60：         0 0 0 0 0 01：         0 0 0 0 0 12：         0 0 0 0 1 03：         0 0 0 0 1 14：         0 0 0 1 0 05：         0 0 0 1 0 16：         0 0 0 1 1 07：         0 0 0 1 1 18：         0 0 1 0 0 09：         0 0 1 0 0 1此处从 0 开始列举，由于 0 的贡献值为 0 ，因此对本题无影响数学规律：第 i 位的 0 ，1 存在周期性变化        对于 i 位置 先是 2^(i-1) 个 0 后是 2^(i-1) 个 1        得出周期为 2^(i-1)+2^(i-1) 即 2^i*///先得到二进制有几位（per）：1LL&lt;&lt;x//对于在一个完整周期（ T ）内的贡献值是： T/2//对于在一个不完整周期（ T ）内的贡献值是： //           -不超过 T/2 ，贡献值为 0 ；//           -超过 T/2 ，则是超过部分个 1 ，即最后一个不完整周期到 T/2 的距离        long long Sum_per(int x,long long num)&#123;        long long per=1LL&lt;&lt;x;        long long ans=per/2*(num/per);        if(num%per&gt;=per/2)&#123;            ans+=num%per-(per/2-1);        &#125;        return ans;    &#125;//是 num 的累加价值    long long Sum(int x,long long num)&#123;        long long ans=0;        int l=64-__builtin_clzll(num);//求出数的二进制的位数（除去前导 0 ）        //位数不可能超过num的最高位：        //假设位数为：x 2x 3x 4x ...nx        //则 nx&lt;= l        for(int i=x;i&lt;=l;i+=x)&#123;            //搜索在第 i 位的累加之和            ans+=Sum_per(i,num);        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3007. 价值和小于等于 K 的最大数字（24.8.21）","date":"2024-08-21T10:20:42.159Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"3970f9e6af23a9c73779a14b099120a6","title":"3154. 到达第 K 级台阶的方案数（24.8.20）","content":"\n今天发晚了，嘿嘿，玩黑神话玩的\n\n题目\n给你有一个 非负 整数 k 。有一个无限长度的台阶，最低 一层编号为 0 。\nAlice 有一个整数 jump ，一开始值为 0 。Alice 从台阶 1 开始，可以使用 任意 次操作，目标是到达第 k 级台阶。假设 Alice 位于台阶 i ，一次 操作 中，Alice 可以：\n向下走一级到 i - 1 ，但该操作 不能 连续使用，如果在台阶第 0 级也不能使用。向上走到台阶 i + 2jump 处，然后 jump 变为 jump + 1 。请你返回 Alice 到达台阶 k 处的总方案数。\n注意，Alice 可能到达台阶 k 处后，通过一些操作重新回到台阶 k 处，这视为不同的方案。\n\n\n示例 1：\n输入：k &#x3D; 0输出：2解释：2 种到达台阶 0 的方案为：\n\nAlice 从台阶 1 开始。- 执行第一种操作，从台阶 1 向下走到台阶 0 。\nAlice 从台阶 1 开始。\n执行第一种操作，从台阶 1 向下走到台阶 0 。\n执行第二种操作，向上走 20 级台阶到台阶 1 。\n执行第一种操作，从台阶 1 向下走到台阶 0 。\n\n\n\n\n\n示例 2：输入：k &#x3D; 1输出：4解释：4 种到达台阶 1 的方案为：\n\nAlice 从台阶 1 开始，已经到达台阶 1 。\n\nAlice 从台阶 1 开始。\n\n执行第一种操作，从台阶 1 向下走到台阶 0 。\n执行第二种操作，向上走 20 级台阶到台阶 1 。\n\n\nAlice 从台阶 1 开始。\n\n执行第二种操作，向上走 20 级台阶到台阶 2 。\n执行第一种操作，向下走 1 级台阶到台阶 1 。\n\n\nAlice 从台阶 1 开始。\n\n执行第一种操作，从台阶 1 向下走到台阶 0 。\n执行第二种操作，向上走 20 级台阶到台阶 1 。\n执行第一种操作，向下走 1 级台阶到台阶 0 。\n执行第二种操作，向上走 21 级台阶到台阶 2 。\n执行第一种操作，向下走 1 级台阶到台阶 1 。\n\n\n\n\n\n提示：\n0 &lt;&#x3D; k &lt;&#x3D; 109\n\n解题思路1234567891011121314151617到达 i 的台阶可以的方式是：  1. 本身就在 i 处  --   1种  2. 通过 上升 得到     3. 通过 下降 得到  4. 先上升 后下降  5. 先下降 后上升其实可以简化为：  1. 本身就在 i 处  --   1种  2. 先上升了(先假设为 a ) 2^0+2^1+2^2+...+2^(n-1) 后下降了b  总数为： 1+a-b --&gt;  2^n-b      2^n-b==k       0 &lt;= k &lt;= 10^9      0 &lt;= b &lt;= n+1    ----&gt;n&lt;30    利用二维数组（设为 c ） //此处为组合    第一维 表示 上升    第二维 表示 下降\n代码123456789101112131415161718192021class Solution &#123;public:    int waysToReachStair(int k) &#123;        const int MAXS=31;        int c[MAXS][MAXS]=&#123;&#125;;        for(int i=0;i&lt;MAXS;i++)&#123;            c[i][0]=c[i][i]=1;            for(int j=1;j&lt;i;j++)&#123;                c[i][j]=c[i-1][j-1]+c[i-1][j];            &#125;        &#125;        int ans=0;        for(int n=0;n&lt;MAXS-1;n++)&#123;            int b=(1&lt;&lt;n)-k;            if(b&gt;=0&amp;&amp;b&lt;=n+1)&#123;                ans+=c[n+1][b];            &#125;        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3154. 到达第 K 级台阶的方案数（24.8.20）","date":"2024-08-20T14:55:17.850Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"810a463297e013419135a0d72cf2bae0","title":"552. 学生出勤记录 II（24.8.19）","content":"题目\n可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：‘A’：Absent，缺勤‘L’：Late，迟到‘P’：Present，到场如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：\n\n\n按 总出勤 计，学生缺勤（’A’）严格 少于两天。学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。\n\n\n示例 1：\n输入：n &#x3D; 2输出：8解释：有 8 种长度为 2 的记录将被视为可奖励：“PP” , “AP”, “PA”, “LP”, “PL”, “AL”, “LA”, “LL”只有”AA”不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n\n\n示例 2：\n输入：n &#x3D; 1输出：3\n\n\n示例 3：输入：n &#x3D; 10101输出：183236316\n\n\n提示：1 &lt;&#x3D; n &lt;&#x3D; 105\n\n解题思路\n&#x2F;&#x2F;3种排列组合为          1 2 3   … n          3 9 27  … 3^n        &#x2F;&#x2F;符合条件的 &#x3D;&#x3D; 总数（3^n） - 不符合条件的           3^n 的数据明显不成立，因此要逐天考虑        &#x2F;&#x2F;不符合条件的情况：          至少含有2个 A，及只需要考虑2个 A 存在的情况，其余的空格排列组合即可          三个连续的 L ，将 LLL 看作一个整体，进行排列组合        （其中有可能存在重合的部分，比如：AALLL,采用dp 从右向左进行【只需要考虑结尾是什么】，则需要考虑 有A 和 无A 的情况，防止重复）        &#x2F;&#x2F;分类讨论：        【假设有 i 天，假设第 i 天符合条件数 为 dp[i] 】        （1）        无A：             1. 第 i 天的记录为 P              …P  以 p 为结尾，以 p 为结尾不会带来任何变化，只需要考虑前 i 天有几个符合要求的              dp[i]&#x3D;dp[i-1]             2.第 i 天的记录为 L              …L 存在特殊情况：以 LLL 为结尾（…LLL），说明不符合，因此 要利用 i-1 天记录为 L 的减去 i-4 天的              dp[i] &#x3D;dp[i-1]-dp[i-4]        （2）        有A: 第 i 个为 A        [0… i-1] A [i+1 … n]        dp[i-1]*dp[n-i]\n\n代码1234567891011121314151617181920212223242526272829class Solution &#123;public:    int checkRecord(int n) &#123;        const long long int MOD=1000000007;        vector&lt;long long int&gt; dp(n+4);//由于LLL的存在，至少要4个        //cout&lt;&lt;dp.size();    //dp 初始化，考虑无A的情况            dp[0]=1; //1种 （2^0-0==1）        dp[1]=2; //2种 P L （2^1-0==2）        dp[2]=4; //4种 PP LP LL PL (2^2-0 ==4)        dp[3]=7; //7种 PPP LPP PLP LLP LLL(X) PLL LPL PPL （2^3-1==7）            //利用 dp 公式进行    for(int i=4;i&lt;=n;i++)&#123;        dp[i]=(2*dp[i-1])%MOD+(MOD-dp[i-4])%MOD;        dp[i]=dp[i]%MOD;//对自身取模，防止越界        //dp[i]=(dp[i-1]) +  (dp[i-1]-dp[i-4])        //      以P为结尾     以L为结尾    &#125;    //加入 A 的情况    long long int ans=dp[n]%MOD;//首先，记录无 A 的情况    for(int i=1;i&lt;=n;i++)    &#123;        ans=(ans%MOD+(dp[i-1]*dp[n-i])%MOD)%MOD;    &#125;    return ans%MOD;    &#125;&#125;;\n\n","slug":"552. 学生出勤记录 II（24.8.19）","date":"2024-08-19T06:42:09.813Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"ccb95229756bc6d7eeab24e5c9a992af","title":"551. 学生出勤记录 I（24.8.18）","content":"题目\n给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： \n\n‘A’：Absent，缺勤\n‘L’：Late，迟到\n‘P’：Present， 到场   如果学生能够 同时 满足下 面两个条件，则可以获得出勤奖励：\n按 总出勤 计，学生缺勤（’A’）严格 少于两天。 \n学生 不会 存在 连续 3 天或 连续 3 天以上的迟（’L’）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。\n\n\n\n示例 1：\n输入：s &#x3D; “PPALLP” 输出：true 解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n\n\n示例 2：\n输入：s &#x3D; “PPALLL” 输出：false 解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。\n\n\n提示：\n\n1 &lt;&#x3D; s.length &lt;&#x3D; 1000\ns[i] 为 ‘A’、’L’ 或 ‘P’\n\n\n解题思路\n本题目直接模拟题目的意思即可，遍历所有的元素，判断使 A，P，L，其中 P 的情况无需做判断，A 需要记录一共存在多少次，L 则需要判断是否连续并且要记录连续的次数，最后判断 A 和 L 是否满足条件即可。\n\n\n优化：只要不符合直接返回 false 减去了很多不必要的判断。\n\n代码12345678910111213141516171819class Solution &#123;public:    bool checkRecord(string s) &#123;        int n=s.size();        int cnt_A=0,cnt_L=0;        for(int i=0;i&lt;n;i++)&#123;            if(s[i]==&#x27;A&#x27;)&#123;                if(++cnt_A&gt;=2) return false;            &#125;             else if(s[i]==&#x27;L&#x27;)&#123;                if(i&amp;&amp;s[i-1]==&#x27;L&#x27;)&#123;                    if(++cnt_L&gt;=3) return false;                &#125;                else cnt_L=1;            &#125;        &#125;        return true;    &#125;&#125;;\n\n","slug":"551. 学生出勤记录 I（24.8.18）","date":"2024-08-18T06:12:33.542Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"cb35c14b3d210d37d2666e2dab45b182","title":"3117. 划分数组得到最小的值之和(24.8.16)","content":"题目\n给你一个长度为 n 的字符串 word 和一个整数 k ，其中 k 是 n 的因数。\n在一次操作中，你可以选择任意两个下标 i 和 j，其中 0 &lt;&#x3D; i, j &lt; n ，且这两个下标都可以被 k 整除，然后用从 j 开始的长度为 k 的子串替换从 i 开始的长度为 k 的子串。也就是说，将子串 word[i..i + k - 1] 替换为子串 word[j..j + k - 1] 。返回使 word 成为 K 周期字符串 所需的 最少 操作次数。如果存在某个长度为 k 的字符串 s，使得 word 可以表示为任意次数连接 s ，则称字符串 word 是 K 周期字符串 。例如，如果 word &#x3D;&#x3D; “ababab”，那么 word 就是 s &#x3D; “ab” 时的 2 周期字符串 。\n\n\n示例 1：\n输入：word &#x3D; “leetcodeleet”, k &#x3D; 4\n输出：1\n解释：可以选择 i &#x3D; 4 和 j &#x3D; 0 获得一个 4 周期字符串。这次操作后，word 变为 “leetleetleet” 。\n\n\n示例 2：\n输入：word &#x3D; “leetcoleet”, k &#x3D; 2\n输出：3\n解释：可以执行以下操作获得一个 2 周期字符串。\n\n\n\ni\nj\nword\n\n\n\n0\n2\netetcoleet\n\n\n4\n0\netetetleet\n\n\n6\n0\netetetetet\n\n\n\n\n提示：\n1 &lt;&#x3D; n &#x3D;&#x3D; word.length &lt;&#x3D; 1051 &lt;&#x3D; k &lt;&#x3D; word.lengthk 能整除 word.length 。word 仅由小写英文字母组成。\n\n解题思路\n本题要求得最少要替换几次才能得到我们的目标字符串，我们可以从另一个角度去思考，假设我们已经得到了用于替换的字符串（长度为 k ），要将所给的字串符改为目标字符串（长度为 n ），我们可以一步一步的替换，则需要 n&#x2F;k 步来完成，其中替换字符串是在所给字符串当中的，因此在所给字符串当中必定存在至少一部分与我们的替换字符一样的子串，对于这样的字串（个数为 Max_char ）我们不需要去替换，因此最终替换步数为 n&#x2F;k-Max_char，在此式子当中  n&#x2F;k 为一个定值，要想答案最小，则需要使 Max_char 最大，那么我们的题目就转变为求所给字符串含由长度为 k 的最多的字串，此步骤可以通过 map+substr 来实现。\n\n代码123456789101112131415class Solution &#123;public:    int minimumOperationsToMakeKPeriodic(string word, int k) &#123;        int n=word.size();        int j=k;int ans=n/k;int Max_char=0;        unordered_map&lt;string,int&gt; cnt;        for(int i=0;i&lt;=n;i+=k)        &#123;            Max_char=max(Max_char,++cnt[word.substr(i,k)]);                    &#125;        ans-=Max_char;        return ans;    &#125;&#125;;\n\n\n\n","slug":"3137. K 周期字符串需要的最少操作次数（24.8.17）","date":"2024-08-17T03:24:30.321Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"cb35c14b3d210d37d2666e2dab45b182","title":"3117. 划分数组得到最小的值之和(24.8.16)","content":"前言今日题目太难，不做过分的解释，仅依据别人的代码进行学习，代码搬自：灵茶山艾府\n题目\n给你两个数组 nums 和 andValues，长度分别为 n 和 m。\n数组的 值 等于该数组的 最后一个 元素。\n你需要将 nums 划分为 m 个 不相交的连续  子数组 ，对于第 ith 个子数组 [li, ri]，子数组元素的按位 AND运算结果等于 andValues[i]，换句话说，对所有的 1 &lt;&#x3D; i &lt;&#x3D; m，nums[li] &amp; nums[li + 1] &amp; … &amp; nums[ri] &#x3D;&#x3D; andValues[i] ，其中 &amp; 表示按位 AND 运算符。\n返回将 nums 划分为 m 个子数组所能得到的可能的 最小 子数组 值 之和。如果无法完成这样的划分，则返回 -1 。\n\n\n示例 1：\n输入： nums &#x3D; [1,4,3,3,2], andValues &#x3D; [0,3,3,2]\n输出： 12\n解释：\n唯一可能的划分方法为：\n[1,4] 因为 1 &amp; 4 &#x3D;&#x3D; 0 [3] 因为单元素子数组的按位 AND 结果就是该元素本身 [3] 因为单元素子数组的按位 AND结果就是该元素本身 [2] 因为单元素子数组的按位 AND 结果就是该元素本身 这些子数组的值之和为 4 + 3 + 3 + 2 &#x3D; 12\n\n\n示例 2：\n输入： nums &#x3D; [2,3,5,7,7,7,5], andValues &#x3D; [0,7,5]\n输出： 17\n解释：\n划分 nums 的三种方式为：\n[[2,3,5],[7,7,7],[5]] 其中子数组的值之和为 5 + 7 + 5 &#x3D; 17 [[2,3,5,7],[7,7],[5]]其中子数组的值之和为 7 + 7 + 5 &#x3D; 19 [[2,3,5,7,7],[7],[5]] 其中子数组的值之和为 7 + 7 + 5 &#x3D;19 子数组值之和的最小可能值为 17\n\n\n示例 3：\n输入： nums &#x3D; [1,2,3,4], andValues &#x3D; [2]\n输出： -1\n解释：\n整个数组 nums 的按位 AND 结果为 0。由于无法将 nums 划分为单个子数组使得元素的按位 AND 结果为 2，因此返回 -1。\n\n\n提示：\n1 &lt;&#x3D; n &#x3D;&#x3D; nums.length &lt;&#x3D; 10^4 1 &lt;&#x3D; m &#x3D;&#x3D; andValues.length &lt;&#x3D; min(n, 10)1 &lt;&#x3D; nums[i] &lt; 10^5 0 &lt;&#x3D; andValues[j] &lt; 10^5\n\n代码123456789101112131415161718192021222324252627282930class Solution &#123;public:    int minimumValueSum(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; andValues) &#123;        const int INF = INT_MAX / 2; // 除 2 防止下面 + nums[i] 溢出        int n = nums.size(), m = andValues.size();        unordered_map&lt;long long, int&gt; memo;        auto dfs = [&amp;](auto&amp;&amp; dfs, int i, int j, int and_) -&gt; int &#123;            if (n - i &lt; m - j) &#123; // 剩余元素不足                return INF;            &#125;            if (j == m) &#123; // 分了 m 段                return i == n ? 0 : INF;            &#125;            and_ &amp;= nums[i];            // 三个参数压缩成一个 long long            long long mask = (long long) i &lt;&lt; 36 | (long long) j &lt;&lt; 32 | and_;            if (memo.contains(mask)) &#123; // 之前计算过                return memo[mask];            &#125;            int res = dfs(dfs, i + 1, j, and_); // 不划分            if (and_ == andValues[j]) &#123; // 划分，nums[i] 是这一段的最后一个数                res = min(res, dfs(dfs, i + 1, j + 1, -1) + nums[i]);            &#125;            return memo[mask] = res; // 记忆化        &#125;;        int ans = dfs(dfs, 0, 0, -1);        return ans &lt; INF ? ans : -1;    &#125;&#125;;\n代码学习\n1.auto dfs &#x3D; [&amp;](auto&amp;&amp; dfs, int i, int j, int and_) -&gt; int： 此处是一个lamada函数体，其基本语法如下：cpp [捕获列表](参数列表) -&gt; 返回值类型 &#123; 函数体 &#125; 捕获列表： 用于指定如何访问外部作用域中的变量。可以是值捕获（[a, b]）、引用捕获（[&amp;a, &amp;b]）或混合捕获。参数列表： 与普通函数的参数列表类似。返回值类型： 可以自动推导（如果函数体只有一个 return 语句），也可以显式指定。函数体： 包含具体的函数逻辑。\n在此代码当中，***[&amp;]*** 代表引用外部全部变量，其后的 auto&amp;&amp; dfs 使用了通用引用。这意味着它可以接受左值引用和右值引用，最后的  -&gt; int 表示其返回值为 int 类型\n\n\n2. unordered_mapunordered_map 是 C++ 标准库中的一种无序关联容器，用于高效地存储键值对并提供快速的查找、插入和删除操作。以下是关于 unordered_map 的一些关键特点和用法：\ncpp //1.插入元素：   \n unordered_map&lt;int, string&gt; myMap;    \n myMap[1] =&quot;One&quot;;   \n myMap.insert(&#123;2, &quot;Two&quot;&#125;);\n //2.查找元素：   \n if (myMap.count(1) &gt;0) &#123;  \n// 检查键是否存在\n   string value = myMap[1];    \n  &#125; \n //3.删除元素：    \nmyMap.erase(1); \n //4.遍历元素：    \nfor (auto it = myMap.begin(); it!= myMap.end(); ++it) &#123;\n    int key = it-&gt;first;\n    string value = it-&gt;second;   \n        &#125; \n","slug":"3117. 划分数组得到最小的值之和(24.8.16)","date":"2024-08-16T09:30:45.146Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"51765fc526760a8b2efb58a734309e35","title":"3148. 矩阵中的最大得分（24.8.15）","content":"题目\n给你一个由 正整数 组成、大小为 m x n 的矩阵grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2的单元格的得分为 c2 - c1 。\n你可以从 任一 单元格开始，并且必须至少移动一次。\n返回你能得到的 最大 总得分。\n\n\n示例 1：\n输入：grid &#x3D; [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n输出：9\n解释：从单元格 (0, 1) 开始，并执行以下移动：\n\n从单元格 (0, 1) 移动到 (2, 1)，得分为 7 - 5 &#x3D; 2 。\n从单元格 (2, 1) 移动到 (2, 2)，得分为 14 - 7 &#x3D; 7 。 总得分为 2 + 7 &#x3D; 9 。\n\n\n\n示例 2：\n输入：grid &#x3D; [[4,3,2],[3,2,1]]\n输出：-1\n解释：从单元格 (0, 0) 开始，执行一次移动：从 (0, 0) 到 (0, 1) 。得分为 3 - 4 &#x3D; -1 。\n\n\n提示：\nm &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length 2 &lt;&#x3D; m,n &lt;&#x3D; 1000 4 &lt;&#x3D; m * n &lt;&#x3D;10^5 1 &lt;&#x3D; grid[i][j] &lt;&#x3D; 10^5\n\n解题思路\n本题考察的时动态规划，由题可知一个点(边界点除外)由一个前置点向下或者向右而得到的值，且至少走一步，则说明前置点和自身不重合，我们可以假设其每次的点只由前置走一步而得到(设走一步得到的值为 d )，假设我们dp每次记录的值为由某个点到此点的最大值，dp的值为 max{ 前置点的最大值，前置点+d }，例如：假设三个点A、B、C，其数值分别为a、b、c，假设A到B、B到C三点均是由一步而得到的，那么对应的数值为b-a、c-b，假设A到C的数值是最大为c-a,其数值其实也等于 (b-a)+(c-b)【前置点+d】 ，假设B到C的数值是最大为c-b,其数值其实也等于 (c-b)【d】，综上所述dp结果应该为 max{ 前置点的最大值，前置点+d}\n注意： dp的初始值不可设为int类型的最小值，因为d的值有可能为负数。对于特殊位置的点需要先处理赋值：对于第一列的点只能由上方的点而得到，第一行的点只能由右方的点得到，对于（0，0）点因为其不可能作为终点而无需处理。对于普通的点由上方一点和左方一点得到。\n\n代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public:    int maxScore(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int m=grid.size(),n=grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,-1e9));        //dp 记录的每一个(i,j)的最大得分，初始值设为int类的最小值        //dp 的更新规则为 max（只走一步，到前置方块的最大值+走一步）        //dp 当中的特殊位置：（0 ，0）只能作为起点，而不能作为终点        int ans=INT_MIN;//用于记录最大值，初始值设为int类的最小值        //处理边界        //对于第一行而言，无向下走的前置方块        //对于第一列而言，无向右走的前置方块        for(int i=1;i&lt;n;i++)        &#123;            //第一行            int d=grid[0][i]-grid[0][i-1];//向右侧走一步            dp[0][i]=max(d,dp[0][i-1]+d);             //更新ans            ans=max(ans,dp[0][i]);        &#125;        for(int i=1;i&lt;m;i++)        &#123;             //第一列             int d=grid[i][0]-grid[i-1][0];//向下走一步            dp[i][0]=max(d,dp[i-1][0]+d);            //更新ans            ans=max(ans,dp[i][0]);        &#125;        //处理内部未处理部分        //此时位置有可能有两个来向，一个向下而来的前置位置，和一个向右而来的前置位置        for(int i=1;i&lt;m;i++)        &#123;            for(int j=1;j&lt;n;j++)            &#123;                int down=grid[i][j]-grid[i-1][j];//向下而来的前置位置走一步得来数值                down=max(down,dp[i-1][j]+down);//将down更新为最大数值                int right=grid[i][j]-grid[i][j-1];//向右而来的前置位置走一步得来数值                right=max(right,dp[i][j-1]+right);//将right更新为最大数值                dp[i][j]=max(down,right);//dp最终值为down和right当中的最大值                ans=max(ans,dp[i][j]);//更新ans            &#125;        &#125;        return ans;    &#125;&#125;;\n\n","slug":"3148. 矩阵中的最大得分（24.8.15）","date":"2024-08-15T09:20:12.824Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"d218398ca55885a65de28626ad7ec930","title":"3152. 特殊数组 II（24.8.14）","content":"题目\n如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n你有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] &#x3D; [fromi, toi]，请你帮助你检查子数组  nums[fromi..toi] 是不是一个 特殊数组 。\n返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true，否则，answer[i] 为 false 。\n\n\n示例 1：\n输入：nums &#x3D; [3,4,1,2,6], queries &#x3D; [[0,4]]\n输出：[false]\n解释：\n子数组是 [3,4,1,2,6]。2 和 6 都是偶数。\n\n\n示例 2：\n输入：nums &#x3D; [4,3,1,6], queries &#x3D; [[0,2],[2,3]]\n输出：[false,true]\n解释：\n子数组是 [4,3,1]。3 和 1 都是奇数。因此这个查询的答案是 false。 子数组是[1,6]。只有一对：(1,6)，且包含了奇偶性不同的数字。因此这个查询的答案是 true。  \n\n\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 1051 &lt;&#x3D; nums[i] &lt;&#x3D; 1051 &lt;&#x3D; queries.length &lt;&#x3D; 105queries[i].length &#x3D;&#x3D; 2 0 &lt;&#x3D; queries[i][0] &lt;&#x3D; queries[i][1] &lt;&#x3D;nums.length - 1\n\n解题思路初次尝试，使用和昨日一样的思路会在最后一个数据当中出现时间超时的状况，因此我们要改变思路，我们可以考虑前缀和的思路，先遍历所有的数字，判断其与前一个数是否满足关系，同一个符合区间内的数值一致。根据区间数组给出的两端数值是否一致进行判断而是否符合标准。\n代码12345678910111213141516171819202122class Solution &#123;public:    vector&lt;bool&gt; isArraySpecial(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int n=nums.size();         vector&lt;int&gt; biao(n);         //记录         for(int i=1;i&lt;n;i++)         &#123;            //符合的数+0 不符合的+1            //同一个符合区间内 记录的数值一致            biao[i]=biao[i-1]+(nums[i-1]%2==nums[i]%2);         &#125;         vector&lt;bool&gt; ans;         n=queries.size();         for(int i=0;i&lt;n;i++)         &#123;            int start=queries[i][0],end=queries[i][1];            ans.push_back(biao[start]==biao[end]);         &#125;        return ans;    &#125;&#125;;\n\n","slug":"3152. 特殊数组 II（24.8.14）","date":"2024-08-14T15:25:52.442Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"a8ad5ce75a8e486bc9d2e5f9a3ff3871","title":"3151. 特殊数组 I（24.8.73）","content":"题目如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。\n你有一个整数数组 nums。如果 nums 是一个 特殊数组 ，返回 true，否则返回 false。\n示例 1：\n输入：nums &#x3D; [1]\n输出：true\n解释：\n只有一个元素，所以答案为 true。\n示例 2：\n输入：nums &#x3D; [2,1,4]\n输出：true\n解释：\n只有两对相邻元素： (2,1) 和 (1,4)，它们都包含了奇偶性不同的数字，因此答案为 true。\n示例 3：\n输入：nums &#x3D; [4,3,1,6]\n输出：false\n解释：\nnums[1] 和 nums[2] 都是奇数。因此答案为 false。\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 1001 &lt;&#x3D; nums[i] &lt;&#x3D; 100\n解题思路从第二个数开始进行比较，直到倒数第二个数比较结束，比较的过程为将自身与相邻两个数进行比较判断其是否为同奇或者同偶，是则返回false，否则继续比较最终返回true。其中需要注意特殊情况是数组只有一个和两个的情况，因为当只有一个时，会出现数组下标为-1和2的情况及越界，第二种情况下则会出现第二个的下表为1，倒数第二个下标为0的状况，两者无法进行比较。\n代码12345678910111213141516171819class Solution &#123;public:    bool isArraySpecial(vector&lt;int&gt;&amp; nums) &#123;        if(nums.size()==1) return true;        if(nums.size()==2)        &#123;            if(nums[0]%2==nums[1]%2)            return false;            else            return true;        &#125;        else for(int i=1;i&lt;=nums.size()-2;i++)        &#123;            if(nums[i]%2==nums[i+1]%2||nums[i]%2==nums[i-1]%2)            return false;        &#125;        return true;    &#125;&#125;;\n","slug":"3151. 特殊数组 I（24.8.13）","date":"2024-08-14T14:02:18.386Z","categories_index":"力扣每日一题 - Cate","tags_index":"Tag","author_index":"木兮xg"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-07-26T15:27:50.230Z","categories_index":"","tags_index":"","author_index":"木兮xg"}]