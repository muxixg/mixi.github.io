{"title":"3177. 求出最长好子序列 II / 3176. 求出最长好子序列 I（24.9.7 / 24.9.8）","uid":"4e6cb60fc0598e549d5e42a48c6c7d34","slug":"3177. 求出最长好子序列 II _ 3176. 求出最长好子序列 I（24.9.7 _ 24.9.8）","date":"2024-09-07T08:34:14.689Z","updated":"2024-09-07T08:35:22.548Z","comments":true,"path":"api/articles/3177. 求出最长好子序列 II _ 3176. 求出最长好子序列 I（24.9.7 _ 24.9.8）.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","content":"<p>昨日与今日题目相同，只有数据量变大了</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个非负整数 <code>k</code>。如果一个整数序列 <code>seq</code> 在范围下标范围 <code>[0, seq.length - 2]</code> 中存在不超过 <code>k</code> 个下标 <code>i</code> 满足 <code>seq[i]!=seq[i + 1]</code>，那么称这个整数序列为好序列。要求返回 <code>nums</code> 中好子序列的最长长度。</p>\n<p><strong>示例 1</strong>：<br>输入：<code>nums = [1,2,1,1,3]</code>，<code>k = 2</code><br>输出：4<br>解释：最长好子序列为 <code>[1,2,1,1]</code>。</p>\n<p><strong>示例 2</strong>：<br>输入：<code>nums = [1,2,3,4,5,1]</code>，<code>k = 0</code><br>输出：2<br>解释：最长好子序列为 <code>[1,1]</code></p>\n<p><strong>提示</strong>：</p>\n<ol>\n<li><code>1 &lt;= nums.length &lt;= 5 * 10^3</code>；</li>\n<li><code>1 &lt;= nums[i] &lt;= 109</code>；</li>\n<li><code>0 &lt;= k &lt;= min(50, nums.length)</code>。</li>\n</ol>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>见代码</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">#1 作为第 i 个数，其有三种情况：</span></span><br><span class=\"line\"><span class=\"comment\">   1.单独作为一个子序列</span></span><br><span class=\"line\"><span class=\"comment\">   2.和上一个好子序列的最后一个相同，加入到结尾</span></span><br><span class=\"line\"><span class=\"comment\">   3.和上一个好子序列的最后一个不相同，但是不超过k，加入到结尾</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">#2 所需要的跟踪信息有：子序列的结尾数，相邻不同的个数</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">#3 dp的构造：</span></span><br><span class=\"line\"><span class=\"comment\">   //1 构造dp[i][j],表示以 nums[i] 作为结尾，至多有 j 个相邻不同的子序列，记录这个下面的最长子序列的长度</span></span><br><span class=\"line\"><span class=\"comment\">   //2 根据 #1 得出下方：</span></span><br><span class=\"line\"><span class=\"comment\">         1.作为子序列的第一个数，dp[i][j]+1;</span></span><br><span class=\"line\"><span class=\"comment\">         2.作为系序列的末尾，并于末尾的数相同，dp[i][j]+1;</span></span><br><span class=\"line\"><span class=\"comment\">         3.作为子序列的末尾，并于末尾的数相同，dp[i][j]=dp[y][j-1]+1;//y为0~i</span></span><br><span class=\"line\"><span class=\"comment\">   //3 dp[i][j]的空间大小：i的值为0~n-1，j的值为0~k</span></span><br><span class=\"line\"><span class=\"comment\">#1 优化</span></span><br><span class=\"line\"><span class=\"comment\">    //dp构造优化：</span></span><br><span class=\"line\"><span class=\"comment\">      根据 #3 的 //1 可以优化构造的方式，其中前面的dp[i]表示以nums[i]作为结尾，我们可以通过哈希的方式快速构建</span></span><br><span class=\"line\"><span class=\"comment\">    unordered_map&lt;int,vector&lt;int&gt;&gt; dp;</span></span><br><span class=\"line\"><span class=\"comment\">    //最大值的维护(对于昨日的I，可以通过暴力枚举y的值而得到，而对于本体暴力枚举则会超时)</span></span><br><span class=\"line\"><span class=\"comment\">    假设最大值为max_v[j-1],用于记录dp[y][j-1]的最大值,避免多次寻找y的最大值</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximumLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;&gt; dp;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">max_v</span><span class=\"params\">(k<span class=\"number\">+2</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num:nums)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span>&amp; d=dp[num];</span><br><span class=\"line\">            d.<span class=\"built_in\">resize</span>(k<span class=\"number\">+1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=k;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//正着循环则会导致同一个数被统计多次</span></span><br><span class=\"line\">                d[j]=<span class=\"built_in\">max</span>(d[j],max_v[j])<span class=\"number\">+1</span>;</span><br><span class=\"line\">                max_v[j<span class=\"number\">+1</span>]=<span class=\"built_in\">max</span>(max_v[j<span class=\"number\">+1</span>],d[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_v[k<span class=\"number\">+1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","feature":true,"text":"昨日与今日题目相同，只有数据量变大了 题目给定一个整数数组 nums 和一个非负整数 k。如果一个整数序列 seq 在范围下标范围 [0, seq.length...","permalink":"/post/3177. 求出最长好子序列 II _ 3176. 求出最长好子序列 I（24.9.7 _ 24.9.8）","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解题思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol>","author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"977. 有序数组的平方（24.9.8）","uid":"c7ae7c3d7dcef23cdefb54305f872c30","slug":"977. 有序数组的平方（24.9.8）","date":"2024-09-08T09:42:29.269Z","updated":"2024-09-08T09:43:42.405Z","comments":true,"path":"api/articles/977. 有序数组的平方（24.9.8）.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","text":"题目问题描述：给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求新数组也按非递减顺序排序。 示例 1： 输入：nums=[-4,...","permalink":"/post/977. 有序数组的平方（24.9.8）","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"3174. 清除数字（24.9.5）","uid":"d669121ea552f56ac2d9d46e47fdc0f9","slug":"3174. 清除数字（24.9.5）","date":"2024-09-05T13:11:54.385Z","updated":"2024-09-05T13:12:41.673Z","comments":true,"path":"api/articles/3174. 清除数字（24.9.5）.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","text":"题目给你一个字符串s。你的任务是重复以下操作删除所有数字字符：删除第一个数字字符以及它左边最近的非数字字符。请你返回删除所有数字字符以后剩下的字符串。 示例 1...","permalink":"/post/3174. 清除数字（24.9.5）","photos":[],"count_time":{"symbolsCount":675,"symbolsTime":"1 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"feature":true}}