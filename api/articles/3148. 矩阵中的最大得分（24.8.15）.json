{"title":"3148. 矩阵中的最大得分（24.8.15）","uid":"51765fc526760a8b2efb58a734309e35","slug":"3148. 矩阵中的最大得分（24.8.15）","date":"2024-08-15T09:20:12.824Z","updated":"2024-09-04T11:34:34.569Z","comments":true,"path":"api/articles/3148. 矩阵中的最大得分（24.8.15）.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>给你一个由 正整数 组成、大小为 m x n 的矩阵<br>grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c1 的单元格移动到值为 c2<br>的单元格的得分为 c2 - c1 。</p>\n<p>你可以从 任一 单元格开始，并且必须至少移动一次。</p>\n<p>返回你能得到的 最大 总得分。</p>\n</blockquote>\n<blockquote>\n<p>示例 1：</p>\n<p>输入：grid &#x3D; [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]</p>\n<p>输出：9</p>\n<p>解释：从单元格 (0, 1) 开始，并执行以下移动：</p>\n<ul>\n<li>从单元格 (0, 1) 移动到 (2, 1)，得分为 7 - 5 &#x3D; 2 。</li>\n<li>从单元格 (2, 1) 移动到 (2, 2)，得分为 14 - 7 &#x3D; 7 。 总得分为 2 + 7 &#x3D; 9 。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>示例 2：</p>\n<p>输入：grid &#x3D; [[4,3,2],[3,2,1]]</p>\n<p>输出：-1</p>\n<p>解释：从单元格 (0, 0) 开始，执行一次移动：从 (0, 0) 到 (0, 1) 。得分为 3 - 4 &#x3D; -1 。</p>\n</blockquote>\n<blockquote>\n<p>提示：</p>\n<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br> 2 &lt;&#x3D; m,<br>n &lt;&#x3D; 1000<br> 4 &lt;&#x3D; m * n &lt;&#x3D;10^5<br> 1 &lt;&#x3D; grid[i][j] &lt;&#x3D; 10^5</p>\n</blockquote>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><blockquote>\n<p>本题考察的时动态规划，由题可知一个点(边界点除外)由一个前置点向下或者向右而得到的值，且至少走一步，则说明前置点和自身不重合，我们可以假设其每次的点只由前置走一步而得到(<br>设走一步得到的值为 d )，假设我们dp每次记录的值为由某个点到此点的最大值，dp的值为 max{ 前置点的最大值，前置点+d }，<br><em><strong>例如：假设三个点A、B、C，其数值分别为a、b、c，假设A到B、B到C三点均是由一步而得到的，那么对应的数值为b-a、c-b，假设A到C的数值是最大为c-a,其数值其实也等于 (b-a)+(c-b)【前置点+d】 ，假设B到C的数值是最大为c-b,其数值其实也等于 (c-b)【d】，综上所述dp结果应该为 max{ 前置点的最大值，前置点+d}</strong></em></p>\n<p><strong>注意：</strong> dp的初始值不可设为int类型的最小值，因为d的值有可能为负数。对于特殊位置的点需要先处理赋值：对于第一列的点只能由上方的点而得到，第一行的点只能由右方的点得到，对于（0<br>，0）点因为其不可能作为终点而无需处理。对于普通的点由上方一点和左方一点得到。</p>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxScore</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m=grid.<span class=\"built_in\">size</span>(),n=grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n,<span class=\"number\">-1e9</span>));</span><br><span class=\"line\">        <span class=\"comment\">//dp 记录的每一个(i,j)的最大得分，初始值设为int类的最小值</span></span><br><span class=\"line\">        <span class=\"comment\">//dp 的更新规则为 max（只走一步，到前置方块的最大值+走一步）</span></span><br><span class=\"line\">        <span class=\"comment\">//dp 当中的特殊位置：（0 ，0）只能作为起点，而不能作为终点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ans=INT_MIN;<span class=\"comment\">//用于记录最大值，初始值设为int类的最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//处理边界</span></span><br><span class=\"line\">        <span class=\"comment\">//对于第一行而言，无向下走的前置方块</span></span><br><span class=\"line\">        <span class=\"comment\">//对于第一列而言，无向右走的前置方块</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//第一行</span></span><br><span class=\"line\">            <span class=\"type\">int</span> d=grid[<span class=\"number\">0</span>][i]-grid[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>];<span class=\"comment\">//向右侧走一步</span></span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i]=<span class=\"built_in\">max</span>(d,dp[<span class=\"number\">0</span>][i<span class=\"number\">-1</span>]+d); </span><br><span class=\"line\">            <span class=\"comment\">//更新ans</span></span><br><span class=\"line\">            ans=<span class=\"built_in\">max</span>(ans,dp[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">             <span class=\"comment\">//第一列</span></span><br><span class=\"line\">             <span class=\"type\">int</span> d=grid[i][<span class=\"number\">0</span>]-grid[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>];<span class=\"comment\">//向下走一步</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>]=<span class=\"built_in\">max</span>(d,dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]+d);</span><br><span class=\"line\">            <span class=\"comment\">//更新ans</span></span><br><span class=\"line\">            ans=<span class=\"built_in\">max</span>(ans,dp[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//处理内部未处理部分</span></span><br><span class=\"line\">        <span class=\"comment\">//此时位置有可能有两个来向，一个向下而来的前置位置，和一个向右而来的前置位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> down=grid[i][j]-grid[i<span class=\"number\">-1</span>][j];<span class=\"comment\">//向下而来的前置位置走一步得来数值</span></span><br><span class=\"line\">                down=<span class=\"built_in\">max</span>(down,dp[i<span class=\"number\">-1</span>][j]+down);<span class=\"comment\">//将down更新为最大数值</span></span><br><span class=\"line\">                <span class=\"type\">int</span> right=grid[i][j]-grid[i][j<span class=\"number\">-1</span>];<span class=\"comment\">//向右而来的前置位置走一步得来数值</span></span><br><span class=\"line\">                right=<span class=\"built_in\">max</span>(right,dp[i][j<span class=\"number\">-1</span>]+right);<span class=\"comment\">//将right更新为最大数值</span></span><br><span class=\"line\">                dp[i][j]=<span class=\"built_in\">max</span>(down,right);<span class=\"comment\">//dp最终值为down和right当中的最大值</span></span><br><span class=\"line\">                ans=<span class=\"built_in\">max</span>(ans,dp[i][j]);<span class=\"comment\">//更新ans</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","feature":false,"text":"题目 给你一个由 正整数 组成、大小为 m x n 的矩阵grid。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 c...","permalink":"/post/3148. 矩阵中的最大得分（24.8.15）","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">题目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解题思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol>","author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"3117. 划分数组得到最小的值之和(24.8.16)","uid":"cb35c14b3d210d37d2666e2dab45b182","slug":"3117. 划分数组得到最小的值之和(24.8.16)","date":"2024-08-16T09:30:45.146Z","updated":"2024-09-04T11:35:34.023Z","comments":true,"path":"api/articles/3117. 划分数组得到最小的值之和(24.8.16).json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","text":"前言今日题目太难，不做过分的解释，仅依据别人的代码进行学习，代码搬自：灵茶山艾府 题目 给你两个数组 nums 和 andValues，长度分别为 n 和 m。...","permalink":"/post/3117. 划分数组得到最小的值之和(24.8.16)","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"3152. 特殊数组 II（24.8.14）","uid":"d218398ca55885a65de28626ad7ec930","slug":"3152. 特殊数组 II（24.8.14）","date":"2024-08-14T15:25:52.442Z","updated":"2024-09-04T11:34:52.245Z","comments":true,"path":"api/articles/3152. 特殊数组 II（24.8.14）.json","keywords":null,"cover":"https://s3.bmp.ovh/imgs/2024/09/04/9813f071f456e3ba.png","text":"题目 如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。 你有一个整数数组 nums 和一个二维整数矩阵 queries，对于...","permalink":"/post/3152. 特殊数组 II（24.8.14）","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"力扣每日一题 - Cate","slug":"力扣每日一题-Cate","count":26,"path":"api/categories/力扣每日一题-Cate.json"}],"tags":[{"name":"Tag","slug":"Tag","count":26,"path":"api/tags/Tag.json"}],"author":{"name":"木兮xg","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2024/07/30/a1a842c36ee5df76.jpg","link":"/","description":"花有重开日，人无再少年。相逢拌酩酊，何必备芳鲜。","socials":{"github":"https://github.com/muxixg","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_60624992","juejin":"","customs":{}}},"feature":false}}